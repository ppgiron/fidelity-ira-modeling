<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and generate all documents in {document_output_language}</critical>

  <critical>üî• CRITICAL MISSION: You are creating the ULTIMATE story context engine that prevents LLM developer mistakes, omissions or
    disasters! üî•</critical>
  <critical>Your purpose is NOT to copy from epics - it's to create a comprehensive, optimized story file that gives the DEV agent
    EVERYTHING needed for flawless implementation</critical>
  <critical>COMMON LLM MISTAKES TO PREVENT: reinventing wheels, wrong libraries, wrong file locations, breaking regressions, ignoring UX,
    vague implementations, lying about completion, not learning from past work</critical>
  <critical>üö® EXHAUSTIVE ANALYSIS REQUIRED: You must thoroughly analyze ALL artifacts to extract critical context - do NOT be lazy or skim!
    This is the most important function in the entire development process!</critical>
  <critical>üî¨ UTILIZE SUBPROCESSES AND SUBAGENTS: Use research subagents, subprocesses or parallel processing if available to thoroughly
    analyze different artifacts simultaneously and thoroughly</critical>
  <critical>‚ùì SAVE QUESTIONS: If you think of questions or clarifications during analysis, save them for the end after the complete story is
    written</critical>
  <critical>üéØ ZERO USER INTERVENTION: Process should be fully automated except for initial epic/story selection or missing documents</critical>

  <step n="1" goal="Determine target story">
    <check if="{{story_path}} is provided by user or user provided the epic and story number such as 2-4 or 1.6 or epic 1 story 5">
      <action>Parse user-provided story path: extract epic_num, story_num, story_title from format like "1-2-user-auth"</action>
      <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
      <action>GOTO step 2a</action>
    </check>

    <action>Check if {{sprint_status}} file exists for auto discover</action>
    <check if="sprint status file does NOT exist">
      <output>üö´ No sprint status file found and no story specified</output>
      <output>
        **Required Options:**
        1. Run `sprint-planning` to initialize sprint tracking (recommended)
        2. Provide specific epic-story number to create (e.g., "1-2-user-auth")
        3. Provide path to story documents if sprint status doesn't exist yet
      </output>
      <ask>Choose option [1], provide epic-story number, path to story docs, or [q] to quit:</ask>

      <check if="user chooses 'q'">
        <action>HALT - No work needed</action>
      </check>

      <check if="user chooses '1'">
        <output>Run sprint-planning workflow first to create sprint-status.yaml</output>
        <action>HALT - User needs to run sprint-planning</action>
      </check>

      <check if="user provides epic-story number">
        <action>Parse user input: extract epic_num, story_num, story_title</action>
        <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
        <action>GOTO step 2a</action>
      </check>

      <check if="user provides story docs path">
        <action>Use user-provided path for story documents</action>
        <action>GOTO step 2a</action>
      </check>
    </check>

    <!-- Auto-discover from sprint status only if no user input -->
    <check if="no user input provided">
      <critical>MUST read COMPLETE {sprint_status} file from start to end to preserve order</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read ALL lines from beginning to end - do not skip any content</action>
      <action>Parse the development_status section completely</action>

      <action>Find the FIRST story (by reading in order from top to bottom) where:
        - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
        - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
        - Status value equals "backlog"
      </action>

      <check if="no backlog story found">
        <output>üìã No backlog stories found in sprint-status.yaml

          All stories are either already created, in progress, or done.

          **Options:**
          1. Run sprint-planning to refresh story tracking
          2. Load PM agent and run correct-course to add more stories
          3. Check if current sprint is complete and run retrospective
        </output>
        <action>HALT</action>
      </check>

      <action>Extract from found story key (e.g., "1-2-user-authentication"):
        - epic_num: first number before dash (e.g., "1")
        - story_num: second number after first dash (e.g., "2")
        - story_title: remainder after second dash (e.g., "user-authentication")
      </action>
      <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
      <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

      <!-- Mark epic as in-progress if this is first story -->
      <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
      <check if="this is first story in epic {{epic_num}}">
        <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
        <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
        <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
        <action>If epic status is "in-progress" ‚Üí no change needed</action>
        <check if="epic status is 'done'">
          <output>üö´ ERROR: Cannot create story in completed epic</output>
          <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
          <output>If you need to add more work, either:</output>
          <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
          <output>2. Create a new epic for additional work</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <check if="epic status is not one of: backlog, contexted, in-progress, done">
          <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
          <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
          <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <output>üìä Epic {{epic_num}} status updated to in-progress</output>
      </check>

      <action>GOTO step 2a</action>
    </check>
    <action>Load the FULL file: {{sprint_status}}</action>
    <action>Read ALL lines from beginning to end - do not skip any content</action>
    <action>Parse the development_status section completely</action>

    <action>Find the FIRST story (by reading in order from top to bottom) where:
      - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
      - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
      - Status value equals "backlog"
    </action>

    <check if="no backlog story found">
      <output>üìã No backlog stories found in sprint-status.yaml

        All stories are either already created, in progress, or done.

        **Options:**
        1. Run sprint-planning to refresh story tracking
        2. Load PM agent and run correct-course to add more stories
        3. Check if current sprint is complete and run retrospective
      </output>
      <action>HALT</action>
    </check>

    <action>Extract from found story key (e.g., "1-2-user-authentication"):
      - epic_num: first number before dash (e.g., "1")
      - story_num: second number after first dash (e.g., "2")
      - story_title: remainder after second dash (e.g., "user-authentication")
    </action>
    <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
    <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

    <!-- Mark epic as in-progress if this is first story -->
    <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
    <check if="this is first story in epic {{epic_num}}">
      <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
      <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
      <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
      <action>If epic status is "in-progress" ‚Üí no change needed</action>
      <check if="epic status is 'done'">
        <output>üö´ ERROR: Cannot create story in completed epic</output>
        <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
        <output>If you need to add more work, either:</output>
        <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
        <output>2. Create a new epic for additional work</output>
        <action>HALT - Cannot proceed</action>
      </check>
      <check if="epic status is not one of: backlog, contexted, in-progress, done">
        <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
        <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
        <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
        <action>HALT - Cannot proceed</action>
      </check>
      <output>üìä Epic {{epic_num}} status updated to in-progress</output>
    </check>

    <action>GOTO step 2a</action>
  </step>

  <step n="2" goal="Load and analyze core artifacts">
    <critical>üî¨ EXHAUSTIVE ARTIFACT ANALYSIS - This is where you prevent future developer fuckups!</critical>

    <!-- Load all available content through discovery protocol -->
    <invoke-protocol name="discover_inputs" />
    <note>Available content: {epics_content}, {prd_content}, {architecture_content}, {ux_content},
    {project_context}</note>

    <!-- Analyze epics file for story foundation -->
    <action>From {epics_content}, extract Epic {{epic_num}} complete context:</action> **EPIC ANALYSIS:**
    <action>Summarize Epic {{epic_num}} objectives and business value</action>
    <action>Extract ALL stories in this epic for cross-story context and dependencies</action>
    <action>Extract our specific story's requirements, user story statement, acceptance criteria</action>
    <action>Extract technical requirements and constraints relevant to this story from the epic</action>
    <action>Extract dependencies on other stories/epics</action>
    <action>Extract source hints pointing to original documents</action>

    <!-- Previous story analysis for context continuity -->
    <check if="story_num > 1">
      <action>Load previous story file: {{story_dir}}/{{epic_num}}-{{previous_story_num}}-*.md</action> **PREVIOUS STORY INTELLIGENCE:**
      <action>Extract and summarize Dev notes and learnings from previous story (e.g., encryption patterns, Dexie.js usage, Web Workers, Zod validation)</action>
      <action>Extract any Review feedback and corrections needed that are relevant</action>
      <action>Identify Files that were created/modified and their patterns (especially for FSD compliance)</action>
      <action>Identify Testing approaches that worked/didn't work</action>
      <action>Document Problems encountered and solutions found (e.g., error handling patterns)</action>
      <action>Summarize Code patterns established (e.g., immutable updates, absolute imports)</action>
      <action>Extract all learnings that could impact current story implementation</action>
    </check>

    <!-- Git intelligence for previous work patterns -->
    <check if="previous story exists AND git repository detected">
      <action>Get last 5 commit titles to understand recent work patterns</action>
      <action>Analyze 1-5 most recent commits for relevance to current story:
        - Files created/modified
        - Code patterns and conventions used
        - Library dependencies added/changed
        - Architecture decisions implemented
        - Testing approaches used
      </action>
      <action>Extract actionable insights for current story implementation</action>
    </check>

    <critical>üèóÔ∏è ARCHITECTURE INTELLIGENCE - Extract everything the developer MUST follow!</critical> **ARCHITECTURE DOCUMENT ANALYSIS:**
    <action>Systematically analyze {architecture_content} for story-relevant requirements:</action>
    <action>Extract **Technical Stack:** Languages, frameworks, libraries with **versions**</action>
    <action>Extract **Code Structure:** FSD layer for component, naming conventions, file patterns, absolute imports</action>
    <action>Extract **API Patterns:** Service structure, endpoint patterns, data contracts, Zod validation</action>
    <action>Extract **Database Schemas:** Tables, relationships, constraints relevant to story, Dexie.js usage</action>
    <action>Extract **Security Requirements:** Authentication patterns, authorization rules, encryption safeguards, key handling</action>
    <action>Extract **Performance Requirements:** UI responsiveness targets (e.g., <100ms), loading state patterns (shimmer/skeleton), Web Worker usage</action>
    <action>Extract **Testing Standards:** Testing frameworks, coverage expectations, test patterns (unit, integration, accessibility)</action>
    <action>Extract **Deployment Patterns:** Environment configurations, build processes (if relevant to story's context)</action>
    <action>Extract **Integration Patterns:** External service integrations, data flows (if relevant to story's context)</action>
    <action>Extract any story-specific requirements that the developer MUST follow</action>
    <action>Identify any architectural decisions that override previous patterns</action>

    <critical>‚ú® UI/UX DESIGN INTELLIGENCE - Ensure aesthetic, usability, and accessibility!</critical> **UI/UX DOCUMENT ANALYSIS:**
    <action>Systematically analyze {ux_content} for story-relevant UI/UX requirements:</action>
    <action>Extract **Design System:** Specific components, theming strategy, customization rules (e.g., MUI, MUI X Data Grid)</action>
    <action>Extract **Key UX Patterns:** "Progressive Density", "Advisor-Grade" aesthetic, Button Hierarchy, Feedback Patterns, Empty States</action>
    <action>Extract **User Journeys:** Relevant flow diagrams or interaction patterns</action>
    <action>Extract **Responsive Strategy:** Breakpoint considerations, mobile behavior for this component</action>
    <action>Extract **Accessibility Standards:** WCAG 2.1 Level AA compliance, keyboard navigation, screen reader support, color contrast</action>
    <action>Extract any specific UI/UX components or design decisions for this story (e.g., table structure, specific fields, formatting)</action>

    <critical>‚õî ANTI-PATTERNS & REUSE - Prevent mistakes, promote efficiency!</critical>
    <action>Identify **Anti-Patterns to Avoid:** (e.g., reinventing data access, direct DB calls, blocking UI thread, unvalidated data)</action>
    <action>Identify **Code Reuse Opportunities:** (e.g., `shared/lib/formatters.ts`, `shared/ui/` components, existing hooks)</action>
  </step>

  <step n="3" goal="Web research for latest technical specifics" optional="true">
    <critical>üåê ENSURE LATEST TECH KNOWLEDGE - Prevent outdated implementations!</critical> **WEB INTELLIGENCE:**
    <action>Identify specific technical areas that require latest version knowledge based on architecture analysis:</action>
    <action>For each critical technology (e.g., React, MUI, Dexie.js), research latest stable version and key changes:
      - Latest API documentation and breaking changes
      - Security vulnerabilities or updates
      - Performance improvements or deprecations
      - Best practices for current version
    </action>
    **EXTERNAL CONTEXT INCLUSION:**
    <action>Include in story any critical latest information the developer needs:
      - Specific library versions and why chosen
      - API endpoints with parameters and authentication
      - Recent security patches or considerations
      - Performance optimization techniques
      - Migration considerations if upgrading
    </action>
  </step>

  <step n="4" goal="Create comprehensive story file">
    <critical>üìù CREATE ULTIMATE STORY FILE - The developer's master implementation guide!</critical>

    <action>Initialize from template.md: {default_output_file}</action>
    <template-output file="{default_output_file}">story_header</template-output>

    <template-output file="{default_output_file}">epic_context</template-output>
    <template-output file="{default_output_file}">previous_story_learnings</template-output>

    <template-output file="{default_output_file}">story_core_description</template-output>
    <template-output file="{default_output_file}">acceptance_criteria</template-output>
    <template-output file="{default_output_file}">tasks_subtasks</template-output>

    <template-output file="{default_output_file}">dev_notes_section</template-output>
    <template-output file="{default_output_file}">project_structure_notes</template-output>
    <template-output file="{default_output_file}">architectural_guardrails</template-output>
    <template-output file="{default_output_file}">ui_ux_design_patterns</template-output>
    <template-output file="{default_output_file}">testing_standards</template-output>
    <template-output file="{default_output_file}">anti_patterns_reuse</template-output>

    <template-output file="{default_output_file}">references_section</template-output>

    <template-output file="{default_output_file}">dev_agent_record</template-output>
    <template-output file="{default_output_file}">expected_file_list</template-output>
    <template-output file="{default_output_file}">change_log</template-output>

    <template-output file="{default_output_file}">story_completion_status</template-output>

    <!-- CRITICAL: Set status to ready-for-dev -->
    <action>Set story Status to: "ready-for-dev"</action>
    <action>Add completion note: "Comprehensive developer guide created with deep artifact analysis."</action>
  </step>

  <step n="5" goal="Update sprint status and finalize">
    <invoke-task>Validate against checklist at {installed_path}/checklist.md using _bmad/core/tasks/validate-workflow.xml</invoke-task>
    <action>Save story document unconditionally</action>

    <!-- Update sprint status -->
    <check if="sprint status file exists">
      <action>Update {{sprint_status}}</action>
      <action>Load the FULL file and read all development_status entries</action>
      <action>Find development_status key matching {{story_key}}</action>
      <action>Verify current status is "backlog" (expected previous state)</action>
      <action>Update development_status[{{story_key}}] = "ready-for-dev"</action>
      <action>Save file, preserving ALL comments and structure including STATUS DEFINITIONS</action>
    </check>

    <action>Report completion</action>
    <output>**üéØ ULTIMATE BMad Method STORY CONTEXT CREATED, {user_name}!**

      **Story Details:**
      - Story ID: {{story_id}}
      - Story Key: {{story_key}}
      - File: {{story_file}}
      - Status: ready-for-dev

      **Next Steps:**
      1. Review the comprehensive story in {{story_file}}
      2. **Optional Quality Competition:** Run the scrum masters `*validate-create-story` to have a fresh LLM systematically review and
      improve the story context
      3. Run dev agents `dev-story` for optimized implementation
      4. Run `code-review` when complete (auto-marks done)

      **Quality Competition Option:** The `*validate-create-story` command runs the story context through an independent LLM in fresh
      context that will:
      - Systematically re-analyze all source documents
      - Identify any misses, omissions, or improvements
      - Compete to create a more comprehensive story context
      - Present findings interactively for your approval
      - Apply improvements to create the ultimate developer implementation guide

      **The developer now has everything needed for flawless implementation!**
    </output>
  </step>

</workflow>